{"repo": "google/gson", "path": "gson/src/main/java/com/google/gson/stream/JsonReader.java", "func_name": "JsonReader.nextQuotedValue", "original_string": "private String nextQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    StringBuilder builder = null;\n    while (true) {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            return new String(buffer, start, len);\n          } else {\n            builder.append(buffer, start, len);\n            return builder.toString();\n          }\n        } else if (c == '\\\\') {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            int estimatedLength = (len + 1) * 2;\n            builder = new StringBuilder(Math.max(estimatedLength, 16));\n          }\n          builder.append(buffer, start, len);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      if (builder == null) {\n        int estimatedLength = (p - start) * 2;\n        builder = new StringBuilder(Math.max(estimatedLength, 16));\n      }\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }", "language": "java", "code": "private String nextQuotedValue(char quote) throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    StringBuilder builder = null;\n    while (true) {\n      int p = pos;\n      int l = limit;\n      /* the index of the first character not yet appended to the builder. */\n      int start = p;\n      while (p < l) {\n        int c = buffer[p++];\n\n        if (c == quote) {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            return new String(buffer, start, len);\n          } else {\n            builder.append(buffer, start, len);\n            return builder.toString();\n          }\n        } else if (c == '\\\\') {\n          pos = p;\n          int len = p - start - 1;\n          if (builder == null) {\n            int estimatedLength = (len + 1) * 2;\n            builder = new StringBuilder(Math.max(estimatedLength, 16));\n          }\n          builder.append(buffer, start, len);\n          builder.append(readEscapeCharacter());\n          p = pos;\n          l = limit;\n          start = p;\n        } else if (c == '\\n') {\n          lineNumber++;\n          lineStart = p;\n        }\n      }\n\n      if (builder == null) {\n        int estimatedLength = (p - start) * 2;\n        builder = new StringBuilder(Math.max(estimatedLength, 16));\n      }\n      builder.append(buffer, start, p - start);\n      pos = p;\n      if (!fillBuffer(1)) {\n        throw syntaxError(\"Unterminated string\");\n      }\n    }\n  }", "code_tokens": ["private", "String", "nextQuotedValue", "(", "char", "quote", ")", "throws", "IOException", "{", "// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.", "char", "[", "]", "buffer", "=", "this", ".", "buffer", ";", "StringBuilder", "builder", "=", "null", ";", "while", "(", "true", ")", "{", "int", "p", "=", "pos", ";", "int", "l", "=", "limit", ";", "/* the index of the first character not yet appended to the builder. */", "int", "start", "=", "p", ";", "while", "(", "p", "<", "l", ")", "{", "int", "c", "=", "buffer", "[", "p", "++", "]", ";", "if", "(", "c", "==", "quote", ")", "{", "pos", "=", "p", ";", "int", "len", "=", "p", "-", "start", "-", "1", ";", "if", "(", "builder", "==", "null", ")", "{", "return", "new", "String", "(", "buffer", ",", "start", ",", "len", ")", ";", "}", "else", "{", "builder", ".", "append", "(", "buffer", ",", "start", ",", "len", ")", ";", "return", "builder", ".", "toString", "(", ")", ";", "}", "}", "else", "if", "(", "c", "==", "'", "'", ")", "{", "pos", "=", "p", ";", "int", "len", "=", "p", "-", "start", "-", "1", ";", "if", "(", "builder", "==", "null", ")", "{", "int", "estimatedLength", "=", "(", "len", "+", "1", ")", "*", "2", ";", "builder", "=", "new", "StringBuilder", "(", "Math", ".", "max", "(", "estimatedLength", ",", "16", ")", ")", ";", "}", "builder", ".", "append", "(", "buffer", ",", "start", ",", "len", ")", ";", "builder", ".", "append", "(", "readEscapeCharacter", "(", ")", ")", ";", "p", "=", "pos", ";", "l", "=", "limit", ";", "start", "=", "p", ";", "}", "else", "if", "(", "c", "==", "'", "'", ")", "{", "lineNumber", "++", ";", "lineStart", "=", "p", ";", "}", "}", "if", "(", "builder", "==", "null", ")", "{", "int", "estimatedLength", "=", "(", "p", "-", "start", ")", "*", "2", ";", "builder", "=", "new", "StringBuilder", "(", "Math", ".", "max", "(", "estimatedLength", ",", "16", ")", ")", ";", "}", "builder", ".", "append", "(", "buffer", ",", "start", ",", "p", "-", "start", ")", ";", "pos", "=", "p", ";", "if", "(", "!", "fillBuffer", "(", "1", ")", ")", "{", "throw", "syntaxError", "(", "\"Unterminated string\"", ")", ";", "}", "}", "}"], "docstring": "Returns the string up to but not including {@code quote}, unescaping any\ncharacter escape sequences encountered along the way. The opening quote\nshould have already been read. This consumes the closing quote, but does\nnot include it in the returned string.\n\n@param quote either ' or \".\n@throws NumberFormatException if any unicode escape sequences are\nmalformed.", "docstring_tokens": ["Returns", "the", "string", "up", "to", "but", "not", "including", "{", "@code", "quote", "}", "unescaping", "any", "character", "escape", "sequences", "encountered", "along", "the", "way", ".", "The", "opening", "quote", "should", "have", "already", "been", "read", ".", "This", "consumes", "the", "closing", "quote", "but", "does", "not", "include", "it", "in", "the", "returned", "string", "."], "sha": "63ee47cb642c8018e5cddd639aa2be143220ad4b", "url": "https://github.com/google/gson/blob/63ee47cb642c8018e5cddd639aa2be143220ad4b/gson/src/main/java/com/google/gson/stream/JsonReader.java#L986-L1035", "partition": "train"}
