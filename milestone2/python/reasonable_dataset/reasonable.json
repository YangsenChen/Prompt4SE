{"function": ["def limited_join(sep, items, max_chars=30, overflow_marker=\"...\"):\n    \"\"\"Join a number of strings to one, limiting the length to *max_chars*.\n\n    If the string overflows this limit, replace the last fitting item by\n    *overflow_marker*.\n\n    Returns: joined_string\n    \"\"\"\n    full_str = sep.join(items)\n    if len(full_str) < max_chars:\n        return full_str\n\n    n_chars = 0\n    n_items = 0\n    for j, item in enumerate(items):\n        n_chars += len(item) + len(sep)\n        if n_chars < max_chars - len(overflow_marker):\n            n_items += 1\n        else:\n            break\n\n    return sep.join(list(items[:n_items]) + [overflow_marker])",
"def count_list(the_list):\n    \"\"\"\n    Generates a count of the number of times each unique item appears in a list\n    \"\"\"\n    count = the_list.count\n    result = [(item, count(item)) for item in set(the_list)]\n    result.sort()\n    return result",
"def get_vid_from_url(url):\n        \"\"\"Extracts video ID from URL.\n        \"\"\"\n        return match1(url, r'youtu\\.be/([^?/]+)') or \\\n          match1(url, r'youtube\\.com/embed/([^/?]+)') or \\\n          match1(url, r'youtube\\.com/v/([^/?]+)') or \\\n          match1(url, r'youtube\\.com/watch/([^/?]+)') or \\\n          parse_query_param(url, 'v') or \\\n          parse_query_param(parse_query_param(url, 'u'), 'v')",
"def _is_iterable(item):\n    \"\"\" Checks if an item is iterable (list, tuple, generator), but not string \"\"\"\n    return isinstance(item, collections.Iterable) and not isinstance(item, six.string_types)",
"def __jaccard(int_a, int_b):  # pragma: no cover\n    '''Jaccard similarity between two intervals\n\n    Parameters\n    ----------\n    int_a, int_b : np.ndarrays, shape=(2,)\n\n    Returns\n    -------\n    Jaccard similarity between intervals\n    '''\n    ends = [int_a[1], int_b[1]]\n    if ends[1] < ends[0]:\n        ends.reverse()\n\n    starts = [int_a[0], int_b[0]]\n    if starts[1] < starts[0]:\n        starts.reverse()\n\n    intersection = ends[0] - starts[1]\n    if intersection < 0:\n        intersection = 0.\n\n    union = ends[1] - starts[0]\n\n    if union > 0:\n        return intersection / union\n\n    return 0.0",
"def string_to_date(input):\n    \"\"\"Convert string to date object.\n\n    :param input: the date string to parse\n    :type input: str\n    :returns: the parsed datetime object\n    :rtype: datetime.datetime\n    \"\"\"\n    # try date formats --mmdd, --mm-dd, yyyymmdd, yyyy-mm-dd and datetime\n    # formats yyyymmddThhmmss, yyyy-mm-ddThh:mm:ss, yyyymmddThhmmssZ,\n    # yyyy-mm-ddThh:mm:ssZ.\n    for format_string in (\"--%m%d\", \"--%m-%d\", \"%Y%m%d\", \"%Y-%m-%d\",\n                          \"%Y%m%dT%H%M%S\", \"%Y-%m-%dT%H:%M:%S\",\n                          \"%Y%m%dT%H%M%SZ\", \"%Y-%m-%dT%H:%M:%SZ\"):\n        try:\n            return datetime.strptime(input, format_string)\n        except ValueError:\n            pass\n    # try datetime formats yyyymmddThhmmsstz and yyyy-mm-ddThh:mm:sstz where tz\n    # may look like -06:00.\n    for format_string in (\"%Y%m%dT%H%M%S%z\", \"%Y-%m-%dT%H:%M:%S%z\"):\n        try:\n            return datetime.strptime(''.join(input.rsplit(\":\", 1)),\n                                     format_string)\n        except ValueError:\n            pass\n    raise ValueError",
"def capwords(s, sep=None):\n    \"\"\"capwords(s [,sep]) -> string\n\n    Split the argument into words using split, capitalize each\n    word using capitalize, and join the capitalized words using\n    join.  If the optional second argument sep is absent or None,\n    runs of whitespace characters are replaced by a single space\n    and leading and trailing whitespace are removed, otherwise\n    sep is used to split and join the words.\n\n    \"\"\"\n    return (sep or ' ').join(x.capitalize() for x in s.split(sep))",
"def split_namespace(clarkName):\n    \"\"\"Return (namespace, localname) tuple for a property name in Clark Notation.\n\n    Namespace defaults to ''.\n    Example:\n    '{DAV:}foo'  -> ('DAV:', 'foo')\n    'bar'  -> ('', 'bar')\n    \"\"\"\n    if clarkName.startswith(\"{\") and \"}\" in clarkName:\n        ns, localname = clarkName.split(\"}\", 1)\n        return (ns[1:], localname)\n    return (\"\", clarkName)",
"def is_likely_benign(bs_terms, bp_terms):\n    \"\"\"Check if criterias for Likely Benign are fullfilled\n\n    The following are descriptions of Likely Benign clasification from ACMG paper:\n\n    Likely Benign\n      (i) 1 Strong (BS1\u2013BS4) and 1 supporting (BP1\u2013 BP7) OR\n      (ii) \u22652 Supporting (BP1\u2013BP7)\n\n    Args:\n        bs_terms(list(str)): Terms that indicate strong evidence for benign variant\n        bp_terms(list(str)): Terms that indicate supporting evidence for benign variant\n\n    Returns:\n        bool: if classification indicates Benign level\n    \"\"\"\n    if bs_terms:\n        # Likely Benign (i)\n        if bp_terms:\n            return True\n    # Likely Benign (ii)\n    if len(bp_terms) >= 2:\n        return True\n\n    return False",
"def tag_to_text(tag):\n    \"\"\"\n    :param tag: Beautiful soup tag\n    :return: Flattened text\n    \"\"\"\n    out = []\n    for item in tag.contents:\n        # If it has a name, it is a tag\n        if item.name:\n            out.append(tag_to_text(item))\n        else:\n            # Just text!\n            out.append(item)\n\n    return ' '.join(out)"]}